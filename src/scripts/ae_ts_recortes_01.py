# -*- coding: utf-8 -*-
"""ae_ts_recortes_01.ipynb

Automatically generated by Colab.

Original file is located at
   
"""

import random
import matplotlib.pyplot as plt
import matplotlib.patches as patches

# -----------------------------------------------------------------------------
# Función que calcula el área ocupada por los recortes en la tela
# -----------------------------------------------------------------------------
def calcular_area_ocupada(posiciones, recortes):
    max_x = max([pos[0] + rec[0] for pos, rec in zip(posiciones, recortes)])
    max_y = max([pos[1] + rec[1] for pos, rec in zip(posiciones, recortes)])
    return max_x * max_y

# -----------------------------------------------------------------------------
# Función que verifica si los recortes se superponen
# -----------------------------------------------------------------------------
def hay_superposicion(posiciones, recortes):
    for i in range(len(recortes)):
        for j in range(i + 1, len(recortes)):
            x1, y1 = posiciones[i]
            x2, y2 = posiciones[j]
            w1, h1 = recortes[i]
            w2, h2 = recortes[j]

            # Verificar si hay superposición en ambos ejes
            if not (x1 + w1 <= x2 or x2 + w2 <= x1 or y1 + h1 <= y2 or y2 + h2 <= y1):
                return True
    return False

# -----------------------------------------------------------------------------
# Función para generar nuevas posiciones adyacentes para recortes
# -----------------------------------------------------------------------------
def generar_posicion_adyacente(posiciones, recortes, max_width, max_height):
    nueva_posicion = posiciones[-1]  # Empezamos desde el último recorte colocado
    ancho_ultimo, alto_ultimo = recortes[-1]

    # Tratar de colocar el siguiente recorte justo a la derecha o abajo del último
    if nueva_posicion[0] + ancho_ultimo < max_width:  # Espacio en el eje X
        nueva_posicion = (nueva_posicion[0] + ancho_ultimo, nueva_posicion[1])
    else:  # Mover hacia abajo en el eje Y si no hay espacio en X
        nueva_posicion = (0, nueva_posicion[1] + alto_ultimo)

    # Si sale del plano, devolver None
    if nueva_posicion[1] + recortes[-1][1] > max_height:
        return None  # No cabe en el plano

    return nueva_posicion


# -----------------------------------------------------------------------------
# generacion de vecindarios
# -----------------------------------------------------------------------------
def generar_vecindarios(posiciones, max_width, max_height):
    vecindarios = []

    for i in range(len(posiciones)):
        nueva_posicion = list(posiciones[i])

        nueva_posicion[0] += random.choice([-1, 1])  #  en X
        nueva_posicion[1] += random.choice([-1, 1])  #  en Y

        if 0 <= nueva_posicion[0] <= max_width and 0 <= nueva_posicion[1] <= max_height:
            nueva_posiciones = posiciones[:]
            nueva_posiciones[i] = tuple(nueva_posicion)
            vecindarios.append(nueva_posiciones)

    return vecindarios


# -----------------------------------------------------------------------------
# Algoritmo de búsqueda tabú para el problema de recortes
# -----------------------------------------------------------------------------
def busqueda_tabu_recortes(recortes, max_width, max_height, num_iteraciones, tamanio_lista_tabu):
    # Inicialización: el primer recorte va en (0, 0)
    posiciones_actuales = [(0, 0)]  # Posición inicial del primer recorte
    for i in range(1, len(recortes)):
        nueva_posicion = generar_posicion_adyacente(posiciones_actuales, recortes[:i], max_width, max_height)
        if nueva_posicion:
            posiciones_actuales.append(nueva_posicion)
        else:
            break  # Si no cabe, salir

    mejor_posicion = posiciones_actuales[:]
    mejor_area = calcular_area_ocupada(mejor_posicion, recortes)

    # Crear la lista tabú
    lista_tabu = []

    for iteracion in range(num_iteraciones):
        # Se genera una nueva posición basada en la anterior
        vecindarios = generar_vecindarios(posiciones_actuales, max_width, max_height)

        # Inicializar variables para encontrar el mejor vecindario
        mejor_vecindario = None
        mejor_area_vecindario = float('inf')

        # Evaluar los vecindarios
        for vecindario in vecindarios:
            if not hay_superposicion(vecindario, recortes):
                area_vecindario = calcular_area_ocupada(vecindario, recortes)
                if vecindario not in lista_tabu and area_vecindario < mejor_area_vecindario:
                    mejor_vecindario = vecindario
                    mejor_area_vecindario = area_vecindario

        # Actualizar la posición actual
        if mejor_vecindario is not None:
            posiciones_actuales = mejor_vecindario[:]
            if mejor_area_vecindario < mejor_area:
                mejor_posicion = mejor_vecindario[:]
                mejor_area = mejor_area_vecindario

        # Actualizar la lista tabú
        lista_tabu.append(mejor_vecindario)
        if len(lista_tabu) > tamanio_lista_tabu:
            lista_tabu.pop(0)

    return mejor_posicion, mejor_area

# -----------------------------------------------------------------------------
# Función para visualizar los recortes
# -----------------------------------------------------------------------------
def graficar_solucion(posiciones, recortes, max_width, max_height):
    fig, ax = plt.subplots()
    ax.set_xlim(0, max_width)
    ax.set_ylim(0, max_height)

    colores = ['red', 'green', 'blue', 'yellow', 'purple']
    for i, (pos, rec) in enumerate(zip(posiciones, recortes)):
        ax.add_patch(patches.Rectangle(pos, rec[0], rec[1], edgecolor='black', facecolor=colores[i], lw=2))

    plt.gca().set_aspect('equal', adjustable='box')
    plt.show()

# -----------------------------------------------------------------------------
# Parámetros y ejecución del algoritmo
# -----------------------------------------------------------------------------
recortes = [(10, 5), (5, 7), (6, 4), (4, 4), (8, 3)]  # Dimensiones de los recortes (ancho, alto)
max_width = 40  # Ancho del plano (tela)
max_height = 40  # Alto del plano (tela)
num_iteraciones = 100
tamanio_lista_tabu = 10

# Ejecutar la búsqueda tabú
mejores_posiciones, mejor_area = busqueda_tabu_recortes(recortes, max_width, max_height, num_iteraciones, tamanio_lista_tabu)

# Graficar el resultado
graficar_solucion(mejores_posiciones, recortes, max_width, max_height)

print(f"Mejor área ocupada: {mejor_area}")