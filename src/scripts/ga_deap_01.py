# -*- coding: utf-8 -*-
"""ga_deap_01.ipynb

Automatically generated by Colab.

"""

!pip install deap

import random
import math # Para pow y otros si fueran necesarios

from deap import base, creator, tools, algorithms

# --- 1. Definición del Problema y Decodificación ---
BOUND_LOW, BOUND_UP = -5.0, 5.0
N_BITS_PER_VARIABLE = 16 # Bits para representar x, y otros bits para y

def decode(individual_bits, n_bits_per_var, low_bound, up_bound):
    """Decodifica una secuencia de bits en un número flotante."""
    int_val = 0
    for bit in individual_bits:
        int_val = (int_val << 1) | bit

    # Escalar al rango deseado
    max_int_val = (1 << n_bits_per_var)
    if max_int_val == 0: # Evitar división por cero si n_bits_per_var es 0
        return low_bound

    scaled_value = low_bound + (int_val / max_int_val) * (up_bound - low_bound)
    return scaled_value

def evalParaboloidBinary(individual):
    # El individuo es una lista de 0s y 1s.
    # Los primeros N_BITS_PER_VARIABLE son para x, los siguientes para y.

    bits_x = individual[:N_BITS_PER_VARIABLE]
    bits_y = individual[N_BITS_PER_VARIABLE:]

    x = decode(bits_x, N_BITS_PER_VARIABLE, BOUND_LOW, BOUND_UP)
    y = decode(bits_y, N_BITS_PER_VARIABLE, BOUND_LOW, BOUND_UP)

    return (x**2 + y**2),

# --- 2. Configuración de DEAP para Binario ---
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

toolbox = base.Toolbox()

# Atributo generador (gen): 0 o 1
toolbox.register("attr_bool", random.randint, 0, 1)

# Individuo: una lista de N_BITS_PER_VARIABLE * 2 bits
TOTAL_N_BITS = N_BITS_PER_VARIABLE * 2
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_bool, n=TOTAL_N_BITS)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

# Operadores genéticos para binario
toolbox.register("evaluate", evalParaboloidBinary)
toolbox.register("mate", tools.cxTwoPoint) # Cruce de dos puntos
toolbox.register("mutate", tools.mutFlipBit, indpb=0.05) # Probabilidad de mutar cada bit
toolbox.register("select", tools.selTournament, tournsize=3)

# --- 3. Ejecución del Algoritmo Genético ---
pop_size = 100
cruceprob = 0.7
mutacionprob = 0.2
num_generaciones = 100

pop = toolbox.population(n=pop_size)
hof = tools.HallOfFame(1)

pop, logbook = algorithms.eaSimple(pop, toolbox, cxpb=cruceprob, mutpb=mutacionprob, ngen=num_generaciones,
                                   halloffame=hof, verbose=True)

best_ind_bits = hof[0]
bits_x_best = best_ind_bits[:N_BITS_PER_VARIABLE]
bits_y_best = best_ind_bits[N_BITS_PER_VARIABLE:]
x_best = decode(bits_x_best, N_BITS_PER_VARIABLE, BOUND_LOW, BOUND_UP)
y_best = decode(bits_y_best, N_BITS_PER_VARIABLE, BOUND_LOW, BOUND_UP)

print("\n--- Resultados ---")
print(f"Mejor individuo (bits): {''.join(map(str,best_ind_bits[:N_BITS_PER_VARIABLE]))} | {''.join(map(str,best_ind_bits[N_BITS_PER_VARIABLE:]))}")
print(f"Mejor individuo decodificado: x={x_best:.4f}, y={y_best:.4f}")
print(f"Fitness del mejor individuo: {best_ind_bits.fitness.values[0]:.4f}")
print(f"El óptimo teórico es [0, 0] con fitness 0.0")